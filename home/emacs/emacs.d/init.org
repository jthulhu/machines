#+title: Emacs init file
#+author: jthulhu
#+startup: overview

My Emacs init.org file.
* Repositories
** Add good repositores
Note that this is only useful to browse available packages inside Emacs, as all packages will
actually be downloaded by Nix.
#+begin_src emacs-lisp :tangle yes 
  (require 'package)
  (add-to-list 'package-archives
	       '("melpa" . "https://melpa.org/packages/"))
  (package-initialize)
#+end_src
** Add `pkg-info`
I'm not sure what this does, but it is apparently required by several other packages, and not
declared as a dependency...
#+begin_src emacs-lisp :tangle yes
  (use-package pkg-info)
#+end_src
* Package Lint
#+begin_src emacs-lisp :tangle yes
  (use-package package-lint)
#+end_src
* Aspect
** Turn off every bar
#+begin_src emacs-lisp :tangle yes
  (setq default-frame-alist '((undecorated . t))
        menu-bar-mode nil
        scroll-bar-mode nil
        tool-bar-mode nil)
  (tool-bar-mode -1)
  (menu-bar-mode -1)
  (scroll-bar-mode -1)
#+end_src
** Remove the startup screen
#+begin_src emacs-lisp :tangle yes
  (setq inhibit-startup-screen t)
#+end_src
** Load my theme
#+begin_src emacs-lisp :tangle yes
  (load-theme 'zenburn t)
#+end_src
** Have a spacemacs-like powerline
Setup wc-modes variable.
#+begin_src emacs-lisp :tangle yes
  (defvar wc-modes '(fundamental-mode org-mode)
    "Which major-mode enable wc in the powerline.")
#+end_src

#+begin_src emacs-lisp :tangle yes
  (use-package spaceline
    :config
    (use-package spaceline-config
      :ensure nil
      :config
      (spaceline-toggle-buffer-encoding-off)
      (spaceline-toggle-buffer-encoding-abbrev-off)
      (setq powerline-default-separator 'rounded)
      (spaceline-define-segment line-column
        "The current line and column numbers."
        "%l|%2c")
      (spaceline-define-segment word-count
        "The number of words in the buffer or region if active."
        (if (use-region-p)
            (format "wc[R]:%s" (count-words-region (region-beginning) (region-end)))
          (format "wc:%s" (count-words-region (point-min) (point-max))))
        :when (and active (member major-mode wc-modes))
        :priority 90)
      (spaceline-spacemacs-theme 'word-count)))
#+end_src

** Setup a dashboard
#+begin_src emacs-lisp :tangle yes
  (use-package dashboard
    :init
    (setq dashboard-items '((recents . 5)
                            (projects . 5))
          dashboard-show-shortcuts nil
          dashboard-center-content nil
          dashboard-banner-logo-title "Welcome to Beansmacs!"
          dashboard-set-init-info t
          initial-buffer-choice (lambda () (switch-to-buffer "*dashboard*")))
    :config
    (dashboard-setup-startup-hook))
#+end_src
** Page break lines
#+begin_src emacs-lisp :tangle yes
  (use-package page-break-lines)
#+end_src
** Rainbow delimeters
This makes it easy to distinguish where parenthesis and alike start and end.
#+begin_src emacs-lisp :tangle yes
  (use-package rainbow-delimiters
    :hook (prog-mode . rainbow-delimiters-mode))
#+end_src
* XKCD
#+begin_src emacs-lisp :tangle yes
  (use-package xkcd
    :custom
    (xkcd-cache-dir "~/.cache/xkcd/" "The directory where the comics are stored.")
    (xkcd-cache-latest "~/.cache/xkcd/latest" "The file where the latest cached comics' number is stored."))
#+end_src
* Emacs
** Global settings
*** Overload `find-file'
Make it open as sudo if invoked with universal argument.
#+begin_src emacs-lisp :tangle yes
  (defun my-find-file (&optional arg)
    (interactive "P")
    (if (not arg)
        (find-file (read-file-name "Find File: "))
      (crux-sudo-edit)))
#+end_src
Make it automatically create unexistent directories.
#+begin_src emacs-lisp :tangle yes
  (defadvice find-file (before make-directory-maybe (filename &optional wildcards) activate)
    "Create parent directory if not exists while visiting file."
    (unless (file-exists-p filename)
      (let ((dir (file-name-directory filename)))
        (unless (file-exists-p dir)
          (make-directory dir t)))))
#+end_src
*** Create command to focus the dashboard
#+begin_src emacs-lisp :tangle yes
  (defun dashboard-focus ()
    (interactive)
    (switch-to-buffer "*dashboard*"))
#+end_src
*** Define the Always Keys minor mode
#+begin_src emacs-lisp :tangle yes
  (defvar always-keys-minor-mode-map
    (let ((map (make-sparse-keymap)))
      (define-key map (kbd "C-c d") #'dashboard-focus)
      (define-key map (kbd "C-M-h") #'windmove-left)
      (define-key map (kbd "C-M-l") #'windmove-right)
      (define-key map (kbd "C-M-j") #'windmove-down)
      (define-key map (kbd "C-M-k") #'windmove-up)
      map)
    "Mode map for the Always Key minor mode.")

  (define-minor-mode always-keys-minor-mode
    "A minor mode to ensure basic moving-around key bindings are enforced."
    :init-value t)
#+end_src
*** Customize emacs
#+begin_src emacs-lisp :tangle yes
  (use-package emacs
    :init
    (setq enable-recursive-minibuffers t
          gc-cons-threshold 104857600	  ; 100mb
          read-process-output-max 1048576	  ; 1mb
          backup-by-copying t
          backup-directory-alist '(("." . "~/backups/emacs/"))
          delete-old-versions t
          kept-new-versions 3
          kept-old-versions 2
          version-control t
          custom-file (concat user-emacs-directory "custom.el"))
    (when (file-exists-p custom-file)
      (load custom-file))
    (setq-default indent-tabs-mode nil)
    :custom
    (repeat-mode t)
    (safe-local-variable-values
     '((eval set-fill-column 117)
       (lsp-rust-analyzer-cargo-target "x86_64-unknown-none")
       (lsp-rust-all-targets nil)))
    (fill-column 97)
    (warning-suppress-types '((direnv)))
    :config
    (put 'lsp-rust-analyzer-cargo-target 'safe-local-variable #'stringp)
    (put 'lsp-rust-all-targets 'safe-local-variable #'stringp)
    :bind (("C-x C-f" . my-find-file)
           ("C-c r s h" . shrink-window-horizontally)
           ("C-c r s v" . shrink-window)
           ("C-c r e h" . enlarge-window-horizontally)
           ("C-c r e v" . enlarge-window)
           ("C-c k" . kill-current-buffer)
           ("S-<return>" . electric-newline-and-maybe-indent)
           ("C-z" . nil)
           ("C-x C-z" . nil)))
#+end_src
*** Alias DEL and M-DEL
#+begin_src emacs-lisp :tangle yes
  (define-key key-translation-map (kbd "C-j") (kbd "DEL"))
  (define-key key-translation-map (kbd "M-j") (kbd "M-DEL"))
#+end_src
*** Redefine jump at begin of line
#+begin_src emacs-lisp :tangle yes
  (defun smart-beginning-of-line (&optional universal-arg)
    "Move point to first non-whitespace character or beginning-of-line.

  Move point to the first non-whitespace character on this line.
  If point was already at that position, move point to beginning of line."
    (interactive "P")
    (if universal-arg
        (beginning-of-line universal-arg)
      (let ((oldpos (point)))
        (back-to-indentation)
        (if (= oldpos (point))
            (beginning-of-line)))))

  (define-key (current-global-map) [remap move-beginning-of-line] #'smart-beginning-of-line)
#+end_src
*** Force newline at the end of a file
#+begin_src emacs-lisp :tangle yes
  (setq-default require-final-newline t)
#+end_src
* Utilities
** Rename both file and buffer at once
Taken from [[http://steve.yegge.googlepages.com/my-dot-emacs-file][Steve Yegge's .emacs]]
#+begin_src emacs-lisp :tangle yes
  (defun rename-file-and-buffer (new-name)
    "Renames both current buffer and file it's visiting to NEW-NAME."
    (interactive (list (read-file-name "New name: " default-directory (buffer-name) nil (buffer-name))))
    (let ((name (buffer-name))
          (filename (buffer-file-name)))
      (if (not filename)
          (message "Buffer '%s' is not visiting a file!" name)
        (if (get-buffer new-name)
            (message "A buffer named '%s' already exists!" new-name)
          (progn
            (rename-file filename new-name 1)
            (rename-buffer new-name)
            (set-visited-file-name new-name)
            (set-buffer-modified-p nil))))))
#+end_src
** Pimped comment-or-uncomment
Not sure this is useful anymore, as I have the impression this was already the default behaviour
of the previous command on <C-x C-o>...
#+begin_src emacs-lisp :tangle yes
  (defun my/comment-or-uncomment ()
    "Comment or uncomment, based on the region."
    (interactive)
    (if (use-region-p)
	(comment-or-uncomment-region (region-beginning) (region-end))
      (comment-or-uncomment-region (line-beginning-position) (line-end-position))))
  (global-set-key (kbd "C-x C-o") #'my/comment-or-uncomment)
#+end_src
** Increment at point
Increments a number at point
#+begin_src emacs-lisp :tangle yes
  (defun incr-at-point (&optional arg)
    (interactive "P")
    (let ((n (prefix-numeric-value-arg arg))
          (old-point (point)))
      (unwind-protect
          (progn
            (skip-chars-backward "-0-9")
            (or (looking-at "-[0-9]+")
                (error "No number at point"))
            (replace-match (number-to-string (+ (string-to-number (match-string 0)) n))))
        (goto-char old-point))))
#+end_src
Bind it to something.
#+begin_src emacs-lisp :tangle yes
  (define-key (current-global-map) (kbd "C-c i") #'incr-at-point)
#+end_src
* God mode
#+begin_src emacs-lisp :tangle no
  (use-package god-mode
    :init
    (global-set-key (kbd "<escape>") #'god-mode-all)
    :config
    (god-mode)
    (define-key god-local-mode-map (kbd "z") #'repeat))
#+end_src
* Flycheck
** Enable flycheck
We enable flycheck for the wanted languages.  We also make flycheck next and previous commands
repeatable.
#+begin_src emacs-lisp :tangle yes
  (use-package flycheck
    :hook (rustic-mode tuareg-mode elisp-mode)
    :config
    (dolist (flycheck-command '(flycheck-next-error flycheck-previous-error))
      (put flycheck-command 'repeat-map 'flycheck-command-map)))
#+end_src
** Enable grammalecte
#+begin_src emacs-lisp :tangle yes
  (use-package flycheck-grammalecte
    :after (flycheck)
    :init (flycheck-grammalecte-setup))
#+end_src
* Tree sitter
#+begin_src emacs-lisp :tangle yes
  (use-package treesit
    :ensure nil
    :init
    (setq major-mode-remap-alist `((bash-mode . bash-ts-mode)
                                   (c++-mode . c++-ts-mode)
                                   (c-mode . c-ts-mode)
                                   (go-mode . go-ts-mode)
                                   (html-mode . html-ts-mode)
                                   (json-mode . json-ts-mode)
                                   (lua-mode . lua-ts-mode)
                                   (python-mode . python-ts-mode)
                                   ;; (rust-mode . rust-ts-mode)
                                   (toml-mode . toml-ts-mode)
                                   (yaml-mode . yaml-ts-mode)
                                   (css-mode . css-ts-mode)
                                   . ,major-mode-remap-alist)))
#+end_src
* Programming languages
** Beans
#+begin_src emacs-lisp :tangle yes
  (use-package beans)
#+end_src
** Rust
*** Rustic
#+begin_src emacs-lisp :tangle yes
  (use-package rustic
    :after rust-mode
    :hook (rustic-mode . font-lock-mode))
#+end_src
*** Flycheck rust
#+begin_src emacs-lisp :tangle yes
  (use-package flycheck-rust
    :commands flycheck-rust-setup
    :hook (flycheck-mode . flycheck-rust-setup))
#+end_src
** Python
*** Setup the `ipython3` interpreter
#+begin_src emacs-lisp :tangle yes
  (use-package python
    :mode ("\\.py\\'" . python-mode)
    :interpreter ("\\.py\\'" . python-mode)
    :when (executable-find "ipython")
    :custom
    (python-shell-interpreter "ipython")
    (python-shell-interpreter-args "--simple-prompt -i")
    (python-shell-prompt-regexp "In \\[[0-9]+\\]: ")
    (python-shell-prompt-output-regexp "Out\\[[0-9]+\\]")
    (python-shell-completion-setup-code "from IPython.core.completerlib import module_completion")
    (python-shell-completion-module-string-code "';'.join(module_completion('''%s'''))\n")
    (python-shell-completion-string-code "';'.join(get_ipython().Completer.all_completions('''%s'''))\n"))
#+end_src
*** Setup the LSP server
#+begin_src emacs-lisp :tangle yes
  (use-package lsp-pyright
    :hook
    (python-mode . (lambda ()
                     (require 'lsp-pyright)
                     (lsp)))
    :defer t)
#+end_src
** OCaml
*** OCP indent
#+begin_src emacs-lisp :tangle yes
  (use-package ocp-indent
    :init
    (setq byte-compile-warnings '(not cl-functions)))
#+end_src
*** Opam
#+begin_src emacs-lisp :tangle yes
  (require 'opam-user-setup "~/.emacs.d/opam-user-setup.el")
#+end_src
*** Tuareg
#+begin_src emacs-lisp :tangle yes
  (use-package tuareg
    :mode
    ("\\.ml\\'" . tuareg-mode)
    ("\\.mli\\'" . tuareg-mode)
    ("\\.mly\\'" . tuareg-menhir-mode)
    :config
    (diminish 'tuareg-mode "üê´"))
#+end_src
*** Utop
#+begin_src emacs-lisp :tangle yes
  (use-package utop
    :hook (tuareg-mode . utop-minor-mode)
    :config
    (setq utop-edit-command nil
          utop-command "dune utop . -- -emacs"))
#+end_src
*** Merlin
#+begin_src emacs-lisp :tangle no
  (use-package merlin
    :hook
    (tuareg-mode . merlin-mode)
    (merlin-mode . company-mode)
    :custom (merlin-command "ocamlmerlin"))
#+end_src
*** Dune
#+begin_src emacs-lisp :tangle yes
  (use-package dune)
#+end_src
** Haskell
#+begin_src emacs-lisp :tangle no
  (use-package lsp-haskell)
#+end_src
** Lisp
*** Racket
#+begin_src emacs-lisp :tangle yes
  (use-package racket-mode
    :hook racket-xp-mode
    :init
    (add-to-list 'auto-mode-alist '("\\.rkt\\'" . racket-mode)))
 #+end_src
*** Scheme
#+begin_src emacs-lisp :tangle yes
  (use-package scheme-complete)
#+end_src
*** Geiser
Geiser seems to be broken for now.
#+begin_src emacs-lisp :tangle no
  (use-package geiser-mit)
#+end_src
*** Quack
Quack seems to dislike `racket-mode`.
#+begin_src emacs-lisp :tangle no
  (use-package quack)
#+end_src
** Bash
*** Bash completion
#+begin_src emacs-lisp :tangle yes 
  (autoload 'bash-completion-dynamic-complete
    "bash completion"
    "BASH completion hook")

  (use-package bash-completion
    :init
    (add-hook 'shell-dynamic-complete-functions 'bash-completion-dynamic-complete))
#+end_src
*** Load Bash aliases
#+begin_src emacs-lisp :tangle yes 
  (use-package load-bash-alias
    :config
    (setq load-bash-alias-bashrc-file "~/.bashrc"))
#+end_src
** LaTeX
*** AUCTeX
#+begin_src emacs-lisp :tangle yes
  (use-package auctex
    :mode ("\\.tex\\'" . latex-mode)
    :hook ((LaTeX-mode . (lambda () (run-hooks 'prog-mode-hook)))
           (LaTeX-mode . flyspell-mode))
    :ensure auctex
    :custom
    (TeX-engine 'luatex)
    (LaTeX-begin-regexp "begin\\b\\|\\[\\|\\If\\b\\|\\ForRange\\b\\|\\For\\b\\|\\Procedure\\b\
  \\|\\While\\b\\|\\Loop\\b")
    (LaTeX-end-regexp "end\\b\\|\\]\\|\\EndIf\\|\\EndFor\\b\\|\\EndProcedure\\b\\|\\EndWhile\\b\
  \\EndLoop\\b")
    (TeX-source-correlate-mode t)
    (TeX-view-program-selection '(((output-dvi has-no-display-manager) "dvi2tty")
                                  (output-dvi style-pstricks)
                                  (output-dvi "xdvi")
                                  (output-pdf "Zathura")
                                  (output-html "xdg-open"))))
  (use-package company-auctex
    :hook (LaTeX-mode . company-mode)
    :init
    (company-auctex-init))
#+end_src
** Typst
#+begin_src emacs-lisp :tangle yes
  (use-package typst-ts-mode
    :after (lsp-mode)
    :ensure nil
    :hook (typst-ts-mode . (lambda () (run-hooks 'prog-mode-hook)))
    :init
    (add-to-list 'lsp-language-id-configuration '(typst-ts-mode . "typst"))
    (lsp-register-client
     (make-lsp-client :new-connection (lsp-stdio-connection '("tinymist"))
                      :major-modes '(typst-ts-mode)
                      :server-id 'typst)))
#+end_src
#+begin_src emacs-lisp :tangle yes
  (use-package typst-preview
    :ensure nil)
#+end_src
** Markdown
*** Pandoc
#+begin_src emacs-lisp :tangle yes
  (use-package pandoc-mode
    :commands pandoc-load-default-settings
    :hook markdown-mode
    (pandoc-mode . pandoc-load-default-settings))
#+end_src
** Nix
*** Nix mode
#+begin_src emacs-lisp :tangle yes 
  (use-package nix-mode
    :after (lsp-mode flycheck)
    :hook (nix-mode . (lambda ()
                        (add-hook 'before-save-hook #'lsp-format-buffer nil 'make-it-local)))
    :init
    (add-to-list 'lsp-language-id-configuration '(nix-mode . "nix"))
    (lsp-register-client
     (make-lsp-client :new-connection (lsp-stdio-connection '("rnix-lsp"))
                      :major-modes '(nix-mode)
                      :server-id 'nix))
    :config
    (diminish 'flycheck-mode)
    (define-key nix-mode-map (kbd "C-c n") #'helm-nixos-options))
#+end_src
*** Direnv
#+begin_src emacs-lisp :tangle yes
  (use-package direnv
    :commands direnv-update-environment
    :hook (prog-mode . direnv-update-environment)
    :config
    (direnv-mode)
    :custom
    (direnv-always-show-summary nil))
#+end_src
** J
#+begin_src emacs-lisp :tangle yes
  (use-package j-mode
    :mode "\\.ijs\\'"
    :hook (j-mode . (lambda ()
                      (run-hooks 'prog-mode-hook)
                      (rainbow-delimiters-mode-disable)))
    :config
    (setq j-console-cmd "jconsole")
    (put 'j-other-face 'face-alias 'font-lock-keyword-face)
    (put 'j-verb-face 'face-alias 'font-lock-keyword-face)
    (put 'j-adverb-face 'face-alias 'font-lock-preprocessor-face)
    (put 'j-conjunction-face 'face-alias 'j-adverb-face))
#+end_src
** Yuck
#+begin_src emacs-lisp :tangle yes
  (use-package yuck-mode)
#+end_src
** Prolog
#+begin_src emacs-lisp :tangle yes
  ;; (use-package prolog)
  (use-package ediprolog)
#+end_src
** Coq
#+begin_src emacs-lisp :tangle yes
  (use-package proof-general
    :hook (proof-mode . font-lock-mode))
  (use-package company-coq
    :hook (coq-mode . company-coq-mode))
#+end_src
** Lean
Lean mode has the sympathy of ignoring user's configuration, enable semantic tokens "by default", without any
way to disable them, and disable electric-indent-mode for no apparent reason. To circumvent these questionable
decisions, one has to hook into the major mode and undo, one by one, their decisions...
#+begin_src emacs-lisp :tangle yes
  (use-package lean4-mode
    :ensure nil
    :bind (:map lean4-mode-map
                ("<backtab>" . #'lean4-eri-indent-reverse)
                ("<tab>" . #'lean4-eri-indent))
    :hook
    (lean4-mode . (lambda ()
                    (setq-local lsp-semantic-tokens-enable nil)
                    (electric-indent-local-mode 1))))
#+end_src
** Agda
#+begin_src emacs-lisp :tangle yes
  (load-file (let ((coding-system-for-read 'utf-8))
               (shell-command-to-string "agda-mode locate")))
#+end_src
** Prog mode
#+begin_src emacs-lisp :tangle yes
  (use-package prog-mode
    :ensure nil
    :hook
    (prog-mode . (lambda () (setq-local display-line-numbers 'relative)))
    ;; (prog-mode . #'display-fill-column-indicator-mode)
    )
#+end_src
** LLVM
#+begin_src emacs-lisp :tangle yes
  (add-to-list 'load-path "~/.emacs.d/llvm-mode")
  (require 'llvm-mode)
  (require 'tablegen-mode)
#+end_src
** System Verilog
#+begin_src emacs-lisp :tangle yes
  (use-package verilog-mode
    :after lsp-mode
    :config
    (lsp-register-client
     (make-lsp-client :new-connection (lsp-stdio-connection '("svls"))
                      :major-modes '(verilog-mode)
                      :priority -1))
    (add-to-list 'lsp-language-id-configuration '(verilog-mode . "verilog"))
    (setq verilog-tool 'verilog-linter
          verilog-linter "svlint"))
#+end_src
** kbd
#+begin_src emacs-lisp :tangle yes
  (use-package kbd-mode
    :ensure nil)
#+end_src
** Lua
#+begin_src emacs-lisp :tangle yes
  (use-package lua-mode)
#+end_src
** Koka
#+begin_src emacs-lisp :tangle yes
  (use-package koka-mode
    :ensure nil)
#+end_src
* SMT solvers
** Z3
This is disabled for the time being, as this package does not compile with the current version of
Emacs... :/
#+begin_src emacs-lisp :tangle no
  (use-package boogie-friends)
#+end_src
* Parenthesis balencing
Automated balancing of parenthesis. Currently using smartparens over paredit because it handles
better other programming languages than lisps.
** Paredit
Currently not used
#+begin_src emacs-lisp :tangle no
  (use-package paredit
    :hook
    ((emacs-lisp-mode
      list-interaction-mode
      ielm-mode
      lisp-mode
      eval-expression-minibuffer-setup
      scheme-mode
      racket-mode
      racket-repl-mode
      dune-mode) . paredit-mode))
#+end_src
** Smartparens
The additional snippet will make it so that when pressing return after just having typed an
opening grouping character, it will insert two newlines instead of just one, and properly indent
both lines. This is because when a brace-like thing is the last character of a line, I usually
want its matching character to be the first non-whitespace character of its line.
#+begin_src emacs-lisp :tangle yes
  (use-package smartparens
    :init
    (require 'smartparens-config)
    :config
    (defun my/indent-after-newline (&rest whatever)
      (interactive)
      (newline)
      (indent-according-to-mode)
      (forward-line -1)
      (indent-according-to-mode))
    (dolist (chr '("{" "[" "("))
      (sp-local-pair 'prog-mode chr nil :post-handlers '((my/indent-after-newline "RET"))))
    :hook
    ((emacs-lisp-mode racket-mode) . smartparens-strict-mode)
    (prog-mode . smartparens-mode))
#+end_src
* HTML Mode
#+begin_src emacs-lisp :tangle yes
  (use-package web-mode)
#+end_src
* Debugger
This has never worked the way I wanted it to, and I haven't used much debuggers, so it's still in
an unfinished state.
#+begin_src emacs-lisp :tangle no
  (use-package dap-mode
    :init
    (dap-register-debug-template
     "Rust::GDB Run Configuration"
     (list :type "gdb"
           :request "launch"
           :name "GDB::Run"
           :gdbpath "rust-gdb"
           :target nil
           :cwd nil)))
#+end_src
* Esup
#+begin_src emacs-lisp :tangle yes
  (use-package esup)
#+end_src
* Data languages
** YAML
Major mode for YAML configuration files.
#+begin_src emacs-lisp :tangle yes
  (use-package yaml-mode
    :mode "\\.yaml\\'")
#+end_src
** TOML
Major mode for TOML configuration files.
#+begin_src emacs-lisp :tangle yes
  (use-package toml-mode
    :mode "\\.toml\\'")
#+end_src
** JSON
Major mode for JSON configuration files.
#+begin_src emacs-lisp :tangle yes
  (use-package json-mode
    :mode "\\.json\\'")
#+end_src
* Diminish
#+begin_src emacs-lisp :tangle yes
  (use-package diminish)
#+end_src
* Company
#+begin_src emacs-lisp :tangle yes
  (use-package company
    :hook (prog-mode . company-mode)
    :config
    (diminish 'company-mode)
    (bind-key [remap completion-at-point] #'company-complete company-mode-map)
    (setq company-show-numbers nil
          company-tooltip-align-annotations t
          company-idle-delay 0
          company-minimum-prefix-length 3))
#+end_src
* Projectile
** Projectile
#+begin_src emacs-lisp :tangle yes
  (use-package projectile
    :hook (prog-mode . projectile-mode)
    :config
    (diminish 'projectile-mode))
#+end_src
  
* Disable font lock in speedbar-mode
Font lock allows customization of the font for selected regions of text.
Speedbar mode doesn't need that.
#+begin_src emacs-lisp :tangle yes
  (setq font-lock-global-modes '(not speedbar-mode))
#+end_src
* Gnutls algorithm
#+begin_src emacs-lisp :tangle yes
  (setq gnutls-algorithm-priority "NORMAL:-VERS-TLS1.3")
#+end_src
* Moving
** Ace window
#+begin_src emacs-lisp :tangle yes
  (use-package ace-window
    :config
    (setq aw-keys '(?q ?s ?d ?f ?g ?h ?j ?k ?l))
    :bind ("M-o" . ace-window))
#+end_src
** Ace jump mode
Fantastic mode that allows you to jump to any location on screen in less than three keystrokes.
However, this seems bugged lately...
#+begin_src emacs-lisp :tangle yes
  (use-package ace-jump-mode
    :bind ("C-." . ace-jump-mode))
#+end_src
** Jump char
Allow to jump even faster to a precise character, both forward and backward
#+begin_src emacs-lisp :tangle yes
  (use-package jump-char
    :bind (("M-h" . jump-char-forward)
	   ("M-m" . jump-char-backward))
    :config
    (setq jump-char-forward-key nil
	  jump-char-backward-key nil))
#+end_src
* Selecting
** Embrace
#+begin_src emacs-lisp :tangle yes
  (use-package embrace
    :bind (("C-," . embrace-commander))
    :hook
    (org-mode . embrace-org-mode-hook)
    (LaTeX-mode . embrace-LaTeX-mode-hook))
#+end_src
** Expand region
#+begin_src emacs-lisp :tangle yes
  (use-package expand-region
    :bind (("M-'" . er/expand-region)))
#+end_src
* Which key
#+begin_src emacs-lisp :tangle yes
  (use-package which-key
    :after (god-mode)  
    :config
    (diminish 'which-key-mode)
    (which-key-enable-god-mode-support))
#+end_src
* Org
** Org
Default configuration
#+begin_src emacs-lisp :tangle yes
  (defun my/text-scale-adjust-latex-previews ()
    "Adjust the size of the latex preview fragments when changing the
  buffer's text scale."
    (pcase major-mode
      ('latex-mode
       (dolist (ov (overlays-in (point-min) (point-max)))
         (if (eq (overlay-get ov 'category)
                 'preview-overlay)
             (my/text-scale--resize-fragment ov))))
      ('org-mode
       (dolist (ov (overlays-in (point-min) (point-max)))
         (if (eq (overlay-get ov 'org-overlay-type)
                 'org-latex-overlay)
             (my/text-scale--resize-fragment ov))))))

  (defun my/text-scale--resize-fragment (ov)
    (overlay-put
     ov 'display
     (cons 'image
           (plist-put
            (cdr (overlay-get ov 'display))
            :scale (+ 1.0 (* 0.25 (- text-scale-mode-amount 2)))))))

  (use-package org
    :hook (text-scale-mode . my/text-scale-adjust-latex-previews)
    :config
    (setq org-agenda-start-on-weekday 1
          org-modules '(ol-bbdb ol-bibtex ol-docview ol-gnus org-habit ol-info ol-irc ol-mhe ol-rmail ol-w3m)
          org-agenda-files (list "~/org/head.org" "~/org/school.org")
          org-preview-latex-default-process 'dvisvgm)
    (add-hook 'org-mode-hook (lambda () (setq-local backup-by-copying t)))
    :custom-face
    (org-level-1 ((t (:inherit outline-1 :height 1.25))))
    (org-level-2 ((t (:inherit outline-1 :height 1.2))))
    (org-level-3 ((t (:inherit outline-1 :height 1.15))))
    (org-level-4 ((t (:inherit outline-1 :height 1.1))))
    (org-level-5 ((t (:inherit outline-1 :height 1.05)))))
#+end_src
Auto-tangle
#+begin_src emacs-lisp :tangle yes
  (use-package org-auto-tangle
    :hook (org-mode . org-auto-tangle-mode)
    :init (setq org-auto-tangle-default t))
#+end_src
** Pdf handling
#+begin_src emacs-lisp :tangle yes
  (use-package pdf-tools)
#+end_src
** Bibliography handling
#+begin_src emacs-lisp :tangle yes
  (use-package ebib)
#+end_src
#+begin_src emacs-lisp :tangle yes
  (use-package biblio)
#+end_src

#+begin_src emacs-lisp :tangle yes
  (use-package ebib-biblio
    :ensure nil
    :after (ebib biblio)
    :bind (:map ebib-index-mode-map ("B" . ebib-biblio-import-doi)
           :map biblio-selection-mode-map ("e" . ebib-biblio-selection-import)))
#+end_src
** Org-modern
This takes care of prettifying org documents, making org mode having a modern look.
#+begin_src emacs-lisp :tangle yes
  (use-package org-modern
    :after (org)
    :hook (org-mode . org-modern-mode))
#+end_src
** SSG exporters
These allow you to build static websites (such as blogs) based on org-mode documents.
*** Hugo
#+begin_src emacs-lisp :tangle yes
  (use-package ox-hugo)
#+end_src
*** Zola
#+begin_src emacs-lisp :tangle no
  (use-package ox-zola
    :after ox-hugo)
#+end_src
* LSP
** Setup main LSP
#+begin_src emacs-lisp :tangle yes
  (use-package lsp-mode
    :after (direnv)
    :init
    (setq lsp-keymap-prefix "C-c l"
          lsp-log-io nil)
    :config
    (diminish 'lsp-lens-mode)
    (define-key lsp-mode-map (kbd "C-c l") lsp-command-map)
    (setq lsp-file-watch-ignored '("[/\\\\]build$"
                                   "[/\\\\].lake$"
                                   "[/\\\\]\\.direnv$"
                                   "[/\\\\]target$"
                                   "[/\\\\]\\.git")
          lsp-enable-suggest-server-download nil)
    :hook ((python-mode . lsp-deferred)
           (rust-mode . lsp-deferred)
           (typst-ts-mode . lsp-deferred)
           (tuareg-opam-mode . lsp-deferred)
           (nix-mode . lsp-deferred)
           (haskell-mode . lsp-deferred)
           (c-mode . lsp-deferred)
           (verilog-mode . lsp-deferred)
           (tuareg-mode . lsp-deferred)
           (lsp-mode . lsp-enable-which-key-integration))
    :commands (lsp lsp-deferred))
#+end_src
** LSP ui
#+begin_src emacs-lisp :tangle yes
  (use-package lsp-ui
    :commands lsp-ui-mode)
#+end_src
* Yasnippet
** Yasnippet
#+begin_src emacs-lisp :tangle yes
  (use-package yasnippet
    :bind (("M-n" . yas-next-field)
           ("M-p" . yas-prev-field)
           ("<C-return>" . yas-exit-snippet))
    :hook
    ((prog-mode org-mode) . yas-minor-mode)
    :config
    (diminish 'yas-minor-mode)
    (setq yas-verbosity 1
          yas-wrap-around-region t
          yas-snippet-dirs '(yasnippet-snippets-dir))
    (define-key yas-minor-mode-map (kbd "<tab>") nil)
    (define-key yas-minor-mode-map (kbd "TAB") nil)
    (define-key yas-minor-mode-map (kbd "M-<tab>") #'yas-expand))
#+end_src
** Actual snippets
#+begin_src emacs-lisp :tangle yes
  (use-package yasnippet-snippets)
#+end_src
* Minibuffer
** Vertico
#+begin_src emacs-lisp :tangle yes
  (use-package vertico
    :init
    (vertico-mode))
#+end_src
** Orderless
#+begin_src emacs-lisp :tangle yes
  (use-package orderless
    :custom
    (completion-styles '(orderless basic))
    (completion-category-defaults nil)
    (completion-category-overrides '((file (styles partial-completion)))))
#+end_src
** Marginalia
#+begin_src emacs-lisp :tangle yes
  (use-package marginalia
    :init
    (marginalia-mode))
#+end_src
* TRAMP
** Tramp configuration
This seems buggy
#+begin_src emacs-lisp :tangle no
  (use-package tramp
    :config
    (setq password-cache-expiry nil))
#+end_src
Instead, let's set directly that value
#+begin_src emacs-lisp :tangle yes
  (setq password-cache-expiry nil)
#+end_src
#+begin_src emacs-lisp :tangle yes
  (use-package auth-source
    :ensure nil
    :custom
    (auth-source-save-behavior nil))
#+end_src
* Save place and history
** Save place
#+begin_src emacs-lisp :tangle yes
  (setq save-place-mode t)
#+end_src
** Save history
#+begin_src emacs-lisp :tangle yes
  (use-package savehist
    :ensure nil
    :init
    (savehist-mode))
#+end_src
* Crux
#+begin_src emacs-lisp :tangle yes 
  (use-package crux
    :bind (("C-c e" . crux-eval-and-replace)))
#+end_src
* Magit
#+begin_src emacs-lisp :tangle yes
  (use-package magit
    :bind (("C-x g" . magit-status)
	   ("C-x M-g" . magit-dispatch)
	   ("C-C M-g" . magit-file-dispatch)))
#+end_src
* ElDoc
#+begin_src emacs-lisp :tangle yes
  (use-package eldoc
    :config
    (diminish 'eldoc-mode))
#+end_src
* Eshell
#+begin_src emacs-lisp :tangle yes
  (use-package eshell
    :ensure nil
    :bind (("<f1>" . eshell)))
#+end_src

* Unison
A major mode for editing unison configuration files.
#+begin_src emacs-lisp :tangle yes
  (use-package unison-mode)
#+end_src

* Pass
#+begin_src emacs-lisp :tangle yes
  (use-package pass
    :bind (("C-c p" . pass)))
  (use-package pinentry)
#+end_src

* Search
** Deadgrep
#+begin_src emacs-lisp :tangle yes
  (use-package deadgrep
    :bind ("<f5>" . deadgrep))
#+end_src

* All the icons
** Base package
#+begin_src emacs-lisp :tangle yes
  (use-package all-the-icons
    :if (display-graphic-p))
#+end_src
** Completions
#+begin_src emacs-lisp :tangle yes
  (use-package all-the-icons-completion
    :after (marginalia all-the-icons)
    :hook (marginalia-mode . all-the-icons-completion-marginalia-setup)
    :init
    (all-the-icons-completion-mode))
#+end_src
